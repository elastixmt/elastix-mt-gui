;--------------------------------------------------------------------------------;
; Do NOT edit this file as it is auto-generated by Elastix. All modifications to ;
; this file must be done via the web gui. There are alternative files to make    ;
; custom modifications ;
;--------------------------------------------------------------------------------;
;
; This file is based in the dialplan created by FreePBX.
; It has been adapted to support multitenant architecture and other functions has been added 
;
;    FreePBX is free software: you can redistribute it and/or modify
;    it under the terms of the GNU General Public License as published by
;    the Free Software Foundation, either version 2 of the License, or
;    (at your option) any later version.
;
;    The contents of this file are subject to the General Public License  
;    (GPL) Version 2 (the "License"); you may not use this file except in 
;    compliance with the License. You may obtain a copy of the License at 
;    http://www.opensource.org/licenses/gpl-license.php                   
;                                                                       
;    Software distributed under the License is distributed on an "AS IS"  
;    basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See  
;    the License for the specific language governing rights and           
;    limitations under the License.       
;    The Original Code is: FreePBX.                           
;    The Initial Developer of the Original Code is FreePBX    
;    Adaptation : Elastix - PaloSanto Solutions
; 
; dialparties.agi (http://www.sprackett.com/asterisk/)
; Asterisk::AGI (http://asterisk.gnuinter.net/)
; gsm (http://www.ibiblio.org/pub/Linux/utils/compress/!INDEX.short.html)
; loligo sounds (http://www.loligo.com/asterisk/sounds/)
; mpg123 (http://voip-info.org/wiki-Asterisk+config+musiconhold.conf)


; include extension contexts generated from AMP
#include organizations/{DOMAIN}/extensions_additionals.conf

; Customizations to this dialplan should be made in extensions_custom.conf
; See extensions_custom.conf.sample for an example.
; If you need to use [macro-dialout-trunk-predial-hook], [ext-did-custom], or
; [from-internal-custom] for example, place these in this file or they will get overwritten.
;
#include organizations/{DOMAIN}/extensions_custom.conf

[{CODE}-from-digital]
include => {CODE}-from-pstn

[{CODE}-from-analog]
include => {CODE}-from-dahdi

[{CODE}-from-trunk]             ; just an alias since VoIP shouldn't be called PSTN
include => {CODE}-from-pstn

[{CODE}-from-pstn]
include => {CODE}-from-pstn-custom      ; create this context in extensions_custom.conf to include customizations
include => {CODE}-ext-did
include => {CODE}-ext-did-post-custom
include => {CODE}-from-did-direct       ; MODIFICATION (PL) for findmefollow if enabled, should be before ext-local
include => {CODE}-ext-did-catchall      ; THIS MUST COME AFTER ext-did


; MODIFICATION (PL)
;
; Required to assure that direct dids go to personal ring group before local extension.
; This could be auto-generated however I it is preferred to be put here and hard coded
; so that it can be modified if ext-local should take precedence in certain situations.
; will have to decide what to do later.
;
[{CODE}-from-did-direct]
include => {CODE}-ext-findmefollow
include => {CODE}-ext-local


; ############################################################################
; Macros [macro]
; ############################################################################

; Rings one or more extensions.  Handles things like call forwarding and DND
; We don't call dial directly for anything internal anymore.
; ARGS: $TIMER, $OPTIONS, $EXT1, $EXT2, $EXT3, ...
; Use a Macro call such as the following:
;  Macro(dial,$DIAL_TIMER,$DIAL_OPTIONS,$EXT1,$EXT2,$EXT3,...)
[macro-{CODE}-dial]
exten => s,1,GotoIf($["${MOHCLASS}" = ""]?dial)
exten => s,n,SetMusicOnHold(${MOHCLASS})
exten => s,n(dial),AGI(dialparties.agi,{CODE})
exten => s,n,NoOp(Returned from dialparties with no extensions to call and DIALSTATUS: ${DIALSTATUS})

exten => s,n+2(normdial),Dial(${ds})                               ; dialparties will set the priority to 10 if $ds is not null
exten => s,n,Set(DIALSTATUS=${IF($["${DIALSTATUS_CW}"!="" ]?${DIALSTATUS_CW}:${DIALSTATUS})})
exten => s,n,GosubIf($["${SCREEN}" != "" | "${DIALSTATUS}" = "ANSWER"]?${DIALSTATUS},1)

exten => s,20(huntdial),NoOp(Returned from dialparties with hunt groups to dial )
exten => s,n,Set(HuntLoop=0)
exten => s,n(a22),GotoIf($[${HuntMembers} >= 1]?a30)  ; if this is from rg-group, don't strip prefix
exten => s,n,NoOp(Returning there are no members left in the hunt group to ring)

; dialparties.agi has setup the dialstring for each hunt member in a variable labeled HuntMember0, HuntMember1 etc for each iteration
; and The total number in HuntMembers. So for each iteration, we will update the CALLTRACE Data.
;
exten => s,n+2(a30),Set(HuntMember=HuntMember${HuntLoop})
exten => s,n,GotoIf($[$["${CALLTRACE_HUNT}" != "" ] & $[$["${RingGroupMethod}" = "hunt" ] | $["${RingGroupMethod}" = "firstavailable"] | $["${RingGroupMethod}" = "firstnotonphone"]]]?a32:a35)

exten => s,n(a32),Set(CT_EXTEN=${CUT(FILTERED_DIAL,,$[${HuntLoop} + 1])})
exten => s,n,Set(DB(CALLTRACE/{CODE}/${CT_EXTEN})=${CALLTRACE_HUNT})
exten => s,n,Goto(s,a42)

;Set Call Trace for each hunt member we are going to call "Memory groups have multiple members to set CALL TRACE For" hence the loop
;
exten => s,n(a35),GotoIf($[$["${CALLTRACE_HUNT}" != "" ] & $["${RingGroupMethod}" = "memoryhunt" ]]?a36:a50)
exten => s,n(a36),Set(CTLoop=0)
exten => s,n(a37),GotoIf($[${CTLoop} > ${HuntLoop}]?a42)  ; if this is from rg-group, don't strip prefix
exten => s,n,Set(CT_EXTEN=${CUT(FILTERED_DIAL,,$[${CTLoop} + 1])})
exten => s,n,Set(DB(CALLTRACE/{CODE}/${CT_EXTEN})=${CALLTRACE_HUNT})
exten => s,n,Set(CTLoop=$[1 + ${CTLoop}])
exten => s,n,Goto(s,a37)

exten => s,n(a42),Dial(${${HuntMember}}${ds})
exten => s,n,GotoIf($["${DIALSTATUS}" = "ANSWER"]?ANSWER,1)
exten => s,n,Set(HuntLoop=$[1 + ${HuntLoop}])
exten => s,n,GotoIf($[$[$["foo${RingGroupMethod}" != "foofirstavailable"] & $["foo${RingGroupMethod}" != "foofirstnotonphone"]] | $["foo${DialStatus}" = "fooBUSY"]]?a46)
exten => s,n,Set(HuntMembers=0)
exten => s,n(a46),Set(HuntMembers=$[${HuntMembers} - 1])
exten => s,n,Goto(s,a22)

exten => s,n(a50),DBdel(CALLTRACE/{CODE}/${CT_EXTEN})
exten => s,n,Goto(s,a42)

; For call screening
exten => NOANSWER,1,Macro({CODE}-vm,${SCREEN_EXTEN},BUSY,${IVR_RETVM})
exten => NOANSWER,n,GotoIf($["${IVR_RETVM}" != "RETURN" | "${IVR_CONTEXT}" = ""]?bye)
exten => NOANSWER,n,Return
exten => NOANSWER,n(bye),Macro({CODE}-hangupcall)
exten => TORTURE,1,Goto({CODE}-app-blackhole,musiconhold,1)
exten => TORTURE,n,Macro({CODE}-hangupcall)
exten => DONTCALL,1,Answer
exten => DONTCALL,n,Wait(1)
exten => DONTCALL,n,Zapateller()
exten => DONTCALL,n,Playback(ss-noservice)
exten => DONTCALL,n,Macro({CODE}-hangupcall)
exten => ANSWER,1,Noop(Call successfully answered - Hanging up now)
exten => ANSWER,n,Macro({CODE}-hangupcall,)

; make sure hungup calls go here so that proper cleanup occurs from call confirmed calls and the like
;
exten => h,1,Macro({CODE}-hangupcall)

; get the voicemail context for the user in ARG1
[macro-{CODE}-get-vmcontext]
exten => s,1,Set(VMCONTEXT=${DB(EXTUSER/{CODE}/${ARG1}/voicemail)})
exten => s,2,GotoIf($["foo${VMCONTEXT}" = "foo"]?200:300)
exten => s,200,Set(VMCONTEXT={CODE}-default)
exten => s,300,NoOp()

; For some reason, if I don't run setCIDname, CALLERID(name) will be blank in my AGI
; ARGS: none
[macro-{CODE}-fixcid]
exten => s,1,Set(CALLERID(name)=${CALLERID(name)})

; Ring groups of phones
; ARGS: comma separated extension list
; 1 - Ring Group Strategy
; 2 - ringtimer
; 3 - prefix
; 4 - extension list
[macro-{CODE}-rg-group]
exten => s,1,Macro({CODE}-user-callerid,SKIPTTL) ; already called from ringgroup
exten => s,2,GotoIf($["${CALLERID(name):0:${LEN(${RGPREFIX})}}" != "${RGPREFIX}"]?4:3)  ; check for old prefix
exten => s,3,Set(CALLERID(name)=${CALLERID(name):${LEN(${RGPREFIX})}}) ; strip off old prefix
exten => s,4,Set(RGPREFIX=${ARG3})  ; set new prefix
exten => s,5,Set(CALLERID(name)=${RGPREFIX}${CALLERID(name)})  ; add prefix to callerid name
exten => s,6,Set(RecordMethod=Group)  ; set new prefix
exten => s,7,Macro({CODE}-record-enable,${MACRO_EXTEN},${RecordMethod})
exten => s,8,Set(RingGroupMethod=${ARG1})     ;
exten => s,9,Macro({CODE}-dial,${ARG2},${{CODE}_DIAL_OPTIONS},${ARG4})
exten => s,10,Set(RingGroupMethod='')     


[macro-{CODE}-dialout-trunk-predial-hook]
; this macro intentionally left blank so it may be safely overwritten for any custom
; requirements that an installation may have.
;
; MACRO RETURN CODE: ${PREDIAL_HOOK_RET}
;                    if set to "BYPASS" then this trunk will be skipped
;
exten => s,1,MacroExit()


; Privacy Manager Macro makes sure that any calls that don't pass the privacy manager are presented
; with congestion since there have been observed cases of the call continuing if not stopped with a
; congestion, and this provides a slightly more friendly 'sorry' message in case the user is
; legitimately trying to be cooperative.
;
; Note: the following options are configurable in privacy.conf:
;
;   maxretries = 3 ; default value, number of retries before failing
;   minlength = 10 ; default value, number of digits to be accepted as valid CID
;
[macro-{CODE}-privacy-mgr]
exten => s,1,Set(KEEPCID=${CALLERID(num)})
exten => s,n,GotoIf($["foo${CALLERID(num):0:1}"="foo+"]?CIDTEST2:CIDTEST1)
exten => s,n(CIDTEST1),Set(TESTCID=${MATH(1+${CALLERID(num)})})
exten => s,n,Goto(TESTRESULT)
exten => s,n(CIDTEST2),Set(TESTCID=${MATH(1+${CALLERID(num):1})})
exten => s,n(TESTRESULT),GotoIf($["foo${TESTCID}"="foo"]?CLEARCID:PRIVMGR)
exten => s,n(CLEARCID),Set(CALLERID(num)=)
exten => s,n(PRIVMGR),PrivacyManager(${ARG1},${ARG2})
exten => s,n,GotoIf($["${PRIVACYMGRSTATUS}"="FAILED"]?fail)
exten => s,n,GosubIf($["${CALLED_BLACKLIST}" = "1"]?{CODE}-app-blacklist-check,s,1)
exten => s,n,SetCallerPres(allowed_passed_screen); stop gap until app_privacy.c clears unavailable bit
exten => s,PRIVMGR+101(fail),Noop(STATUS: ${PRIVACYMGRSTATUS} CID: ${CALLERID(num)} ${CALLERID(name)} CALLPRES: ${CALLLINGPRES})
exten => s,n,Playback(sorry-youre-having-problems)
exten => s,n,Playback(goodbye)
exten => s,n,Playtones(congestion)
exten => s,n,Congestion(5)
exten => h,1,Hangup


[{CODE}-from-internal-xfer]
; applications are now mostly all found in from-internal-additional in _custom.conf
include => {CODE}-from-internal-custom
include => {CODE}-parkedcalls

; MODIFIED (PL)
;
; Currently the include for findmefollow is being auto-generated before ext-local which is the desired behavior.
; However, I haven't been able to do anything that I know of to force this. We need to determine if it should
; be hardcoded into here to make sure it doesn't change with some configuration. For now I will leave it out
; until we can discuss this.
;
include => {CODE}-ext-local-confirm
include => {CODE}-findmefollow-ringallv2
include => {CODE}-from-internal-additional
; This causes grief with '#' transfers, commenting out for the moment.
; include => bad-number
exten => s,1,Macro({CODE}-hangupcall)
exten => h,1,Macro({CODE}-hangupcall)

[{CODE}-from-internal]
include => {CODE}-from-internal-xfer
include => {CODE}-bad-number

;------------------------------------------------------------------------
; [macro-setmusic]
;------------------------------------------------------------------------
; CONTEXT:      macro-setmusic
; PURPOSE:      to turn off moh on routes where it is not desired
;
;------------------------------------------------------------------------
[macro-{CODE}-setmusic]
exten => s,1,NoOp(Setting Outbound Route MoH To: ${ARG1})
exten => s,2,Set(CHANNEL(musicclass)=${ARG1}) ; this won't work in 1.2 anymore, could fix in auto-generate if we wanted...
;------------------------------------------------------------------------

; ##########################################
; ## Ring Groups with Confirmation macros ##
; ##########################################
; Used by followme and ringgroups

;------------------------------------------------------------------------
; [macro-dial-confirm]
;------------------------------------------------------------------------
; This has now been incorporated into dialparties. It still only works with ringall
; and ringall-prim strategies. Have not investigated why it doesn't work with
; hunt and memory hunt.
;
;------------------------------------------------------------------------
[macro-{CODE}-dial-confirm]
; This was written to make it easy to use macro-dial-confirm instead of macro-dial in generated dialplans.
; This takes the same parameters, with an additional parameter of the ring group Number
; ARG1 is the timeout
; ARG2 is the DIAL_OPTIONS
; ARG3 is a list of xtns to call - 203-222-240-123123123#-211
; ARG4 is the ring group number

; This sets a unique value to indicate that the channel is ringing. This is used for warning slow
; users that the call has already been picked up.
;
exten => s,1,Set(DB(RG/{CODE}/${ARG4}/${CHANNEL})=RINGING)

; We need to keep that channel variable, because it'll change when we do this dial, so set it to
; fallthrough to every sibling.
;
exten => s,n,Set(__UNIQCHAN=${CHANNEL})

; The calling ringgroup should have set RingGroupMethod appropriately. We need to set two
; additional parameters:
;
; USE_CONFIRMATION, RINGGROUP_INDEX
;
; These are passed to inform dialparties to place external calls through the [grps] context
;
exten => s,n,Set(USE_CONFIRMATION=TRUE)
exten => s,n,Set(RINGGROUP_INDEX=${ARG4})
exten => s,n,Set(ARG4=) ; otherwise it gets passed to dialparties.agi which processes it (prob bug)

exten => s,n,Macro({CODE}-dial,${ARG1},${ARG2},${ARG3})

; delete the variable, if we are here, we are done trying to dial and it may have been left around
;
exten => s,n,Noop(DELETE KEY: RG/{CODE}/${RINGGROUP_INDEX}/${CHANNEL}: ${DB_DELETE(RG/{CODE}/${RINGGROUP_INDEX}/${CHANNEL})})
exten => s,n,Set(USE_CONFIRMATION=)
exten => s,n,Set(RINGGROUP_INDEX=)
;------------------------------------------------------------------------


;------------------------------------------------------------------------
; [ext-local-confirm]
;------------------------------------------------------------------------
; If call confirm is being used in a ringgroup, then calls that do not require confirmation are sent
; to this extension instead of straight to the device.
;
; The sole purpose of sending them here is to make sure we run Macro(auto-confirm) if this
; extension answers the line. This takes care of clearing the database key that is used to inform
; other potential late comers that the extension has been answered by someone else.
;
; ALERT_INFO is deprecated in Asterisk 1.4 but still used throughout the FreePBX dialplan and
; usually set by dialparties.agi. This allows inheritance. Since no dialparties.agi here, set the
; header if it is set.
;
;------------------------------------------------------------------------
[{CODE}-ext-local-confirm]
exten => _LC-.,1,Noop(IN ext-local-confirm with - RT: ${RT}, RG_IDX: ${RG_IDX})
exten => _LC-.,n,GotoIf($["x${ALERT_INFO}"="x"]?godial)
exten => _LC-.,n,SIPAddHeader(Alert-Info: ${ALERT_INFO})
exten => _LC-.,n(godial),dial(${DB(DEVICE/{CODE}/${EXTEN:3}/dial)},${RT},M({CODE}-auto-confirm^${RG_IDX})${{CODE}_DIAL_OPTIONS})

;------------------------------------------------------------------------
; [findmefollow-ringallv2]
;------------------------------------------------------------------------
; This context, to be included in from-internal, implements the PreRing part of findmefollow
; as well as the GroupRing part. It also communicates between the two so that if DND is set
; on the primary extension, and mastermode is enabled, then the other extensions will not ring
;
;------------------------------------------------------------------------
[{CODE}-findmefollow-ringallv2]
exten => _FMPR-.,1,Noop(In FMPR ${FMGRP} with ${EXTEN:5})
exten => _FMPR-.,n,Set(RingGroupMethod=)
exten => _FMPR-.,n,Set(USE_CONFIRMATION=)
exten => _FMPR-.,n,Set(RINGGROUP_INDEX=)
exten => _FMPR-.,n,Macro({CODE}-simple-dial,${EXTEN:5},${FMREALPRERING})
exten => _FMPR-.,n,GotoIf($["${DIALSTATUS}" != "BUSY"]?nodnd)
exten => _FMPR-.,n,Set(DB(FM/DND/{CODE}/${FMGRP}/${FMUNIQUE})=DND)
exten => _FMPR-.,n(nodnd),Noop(Ending FMPR ${FMGRP} with ${EXTEN:5} and dialstatus ${DIALSTATUS})
exten => _FMPR-.,n,Hangup()

exten => _FMGL-.,1,Noop(In FMGL ${FMGRP} with ${EXTEN:5})
exten => _FMGL-.,n,GotoIf($["${DB(FM/DND/{CODE}/${FMGRP}/${FMUNIQUE})}" = "DND"]?dodnd)
exten => _FMGL-.,n,Wait(1)
exten => _FMGL-.,n,GotoIf($["${DB(FM/DND/{CODE}/${FMGRP}/${FMUNIQUE})}" = "DND"]?dodnd)
exten => _FMGL-.,n,Wait(1)
exten => _FMGL-.,n,GotoIf($["${DB(FM/DND/{CODE}/${FMGRP}/${FMUNIQUE})}" = "DND"]?dodnd)
exten => _FMGL-.,n,Wait(${FMPRERING})
exten => _FMGL-.,n,GotoIf($["${DB(FM/DND/{CODE}/${FMGRP}/${FMUNIQUE})}" = "DND"]?dodnd)
exten => _FMGL-.,n,DBDel(FM/DND/{CODE}/${FMGRP}/${FMUNIQUE})
exten => _FMGL-.,n(dodial),Macro({CODE}-dial,${FMGRPTIME},${{CODE}_DIAL_OPTIONS},${EXTEN:5})
exten => _FMGL-.,n,Noop(Ending FMGL ${FMGRP} with ${EXTEN:5} and dialstatus ${DIALSTATUS})
exten => _FMGL-.,n,Hangup()
exten => _FMGL-.,n+10(dodnd),DBDel(FM/DND/{CODE}/${FMGRP}/${FMUNIQUE})
exten => _FMGL-.,n,GotoIf($["${FMPRIME}" = "FALSE"]?dodial)
exten => _FMGL-.,n,Noop(Got DND in FMGL ${FMGRP} with ${EXTEN:5} in ${RingGroupMethod} mode, aborting)
exten => _FMGL-.,n,Hangup()

;------------------------------------------------------------------------
; [block-cf]
;------------------------------------------------------------------------
; This context is set as a target with FORWARD_CONTEXT when Call Forwarding is set to be
; ignored in a ringgroup or other features that may take advantage of this. Server side
; CF is done in dialparties.agi but if a client device forwards a call, it will be caught
; and blocked here.
;------------------------------------------------------------------------
[{CODE}-block-cf]
exten => _X.,1,Noop(Blocking callforward to ${EXTEN} because CF is blocked)
exten => _X.,n,Hangup()

;------------------------------------------------------------------------


;this is where parked calls go if they time-out.  Should probably re-ring
[{CODE}-default]
exten => s,1,Playback(vm-goodbye)
exten => s,2,Macro({CODE}-hangupcall)

; ARG1 -> nobre de la cola
[macro-{CODE}-agent-add]
include => macro-{CODE}-agent-add-custom
exten => s,1,Wait(1)
exten => s,n,Macro({CODE}-user-callerid,SKIPTTL)
exten => s,n(a3),Read(CALLBACKNUM,agent-login,,,,)
exten => s,n,GotoIf($[${LEN(${CALLBACKNUM})}=0]?a5:a7)
exten => s,n(a5),Set(CALLBACKNUM=${IF($[${LEN(${EXTUSER})}=0]?${CALLERID(number)}:${EXTUSER})})
exten => s,n,Set(THISDEVICE=${DB(DEVICE/{CODE}/${REALCALLERIDNUM}_{CODE}/dial)})
exten => s,n,GotoIf($["${CALLBACKNUM}" = ""]?a3)
exten => s,n(a7),GotoIf($["${CALLBACKNUM}" = "${ARG1}"]?invalid)
exten => s,n,GotoIf($["${ARG3}" = "EXTEN" & ${DB_EXISTS(EXTUSER/{CODE}/${CALLBACKNUM}/cidname)} = 0]?invalid)
exten => s,n,GotoIf($["${DB(QPENALTY/{CODE}/${ARG1}/dynmemberonly)}" = "yes" & ${DB_EXISTS(QPENALTY/{CODE}/${ARG1}/agents/${CALLBACKNUM})} != 1]?invalid)
exten => s,n,ExecIf($["${QREGEX}" != ""]?GotoIf($["${REGEX("${QREGEX}" ${CALLBACKNUM})}" = "0"]?invalid))
exten => s,n,ExecIf($["${ARG2}" != ""]?Authenticate(${ARG2}))
; addQueuMember(cola,inferface añadir cola,penalty,option esto vacio,nombre del miembro solo descripcion,interface a monitorear)
exten => s,n,ExecIf($[${DB_EXISTS(EXTUSER/{CODE}/${CALLBACKNUM}/cidname)} = 1]?AddQueueMember(${ARG1},Local/${CALLBACKNUM}@{CODE}-from-queue/n,${DB(QPENALTY/{CODE}/${ARG1}/agents/${CALLBACKNUM})},,${DB(EXTUSER/{CODE}/${CALLBACKNUM}/cidname)},hint:${CALLBACKNUM}@{CODE}-ext-local): ?AddQueueMember(${ARG1},Local/${CALLBACKNUM}@{CODE}-from-queue/n,${DB(QPENALTY/{CODE}/${ARG1}/agents/${CALLBACKNUM})}))
exten => s,n,UserEvent(Agentlogin,Agent: ${CALLBACKNUM})
exten => s,n,Wait(1)
exten => s,n,Playback(agent-loginok&with&extension)
exten => s,n,SayDigits(${CALLBACKNUM})
exten => s,n,Hangup
exten => s,n,MacroExit()
exten => s,n(invalid),Playback(pbx-invalid)
exten => s,n,Goto(a3)

; end of [macro-{CODE}-agent-add]


[macro-{CODE}-agent-del]
include => macro-{CODE}-agent-del-custom
exten => s,1,Wait(1)
exten => s,n,Macro({CODE}-user-callerid,SKIPTTL)
exten => s,n(a3),Read(CALLBACKNUM,agent-logoff,,,,)
exten => s,n,GotoIf($[${LEN(${CALLBACKNUM})}=0]?a5:a7)
exten => s,n(a5),Set(CALLBACKNUM=${IF($[${LEN(${EXTUSER})}=0]?${CALLERID(number)}:${EXTUSER})})
exten => s,n,GotoIf($["${CALLBACKNUM}" = ""]?a3)
exten => s,n(a7),RemoveQueueMember(${ARG1},Local/${CALLBACKNUM}@{CODE}-from-queue/n)
exten => s,n,RemoveQueueMember(${ARG1},Local/${CALLBACKNUM}@{CODE}-from-internal/n)
exten => s,n,UserEvent(RefreshQueue)
exten => s,n,Wait(1)
exten => s,n,Playback(agent-loggedoff)
exten => s,n,Hangup

; end of [macro-{CODE}-agent-del]

; para buscar un numero asignado a marcacion rapida
; ARG1 -> posicion de maracado rapido
; ARG2 -> usuario que tiene la asignacion (puede ser vacio)
[macro-{CODE}-speeddial-lookup]
include => macro-{CODE}-speeddial-lookup-custom
exten => s,1,GotoIf($["${ARG2}"=""]]?lookupsys)
exten => s,n,Set(SPEEDDIALNUMBER=)
exten => s,n(lookupuser),Set(SPEEDDIALNUMBER=${DB(EXTUSER/{CODE}/${ARG2}/speeddials/${ARG1})})
exten => s,n,GotoIf($["${SPEEDDIALNUMBER}"=""]?lookupsys)
exten => s,n,Noop(Found speeddial ${ARG1} for user ${ARG2}: ${SPEEDDIALNUMBER})
exten => s,n,Goto(end)
exten => s,lookupuser+101(lookupsys),Set(SPEEDDIALNUMBER=${DB(sysspeeddials/{CODE}/${ARG1})})
exten => s,n,GotoIf($["${SPEEDDIALNUMBER}"=""]?failed)
exten => s,n,Noop(Found system speeddial ${ARG1}: ${SPEEDDIALNUMBER})
exten => s,n,Goto(end)
exten => s,lookupsys+101(failed),Noop(No system or user speeddial found)
exten => s,n(end),Noop(End of Speeddial-lookup)

; end of [macro-speeddial-lookup]


[macro-{CODE}-record-enable]
include => macro-{CODE}-record-enable-custom
exten => s,1,GotoIf($["${RECORDING_STATE}"!="DISABLED"]?start)
exten => s,n(disabled),MacroExit()
exten => s,n(start),GotoIf($["${BLINDTRANSFER}" = ""]?check)
exten => s,n,ResetCDR(w)
exten => s,n(check),ExecIf($["${ARG1}"=""]?MacroExit())
exten => s,n,GotoIf($["${ARG2}"="Group"]?Group:OUT)
exten => s,n(Group),Set(LOOPCNT=${FIELDQTY(ARG1,-)})
exten => s,n,Set(ITER=1)
exten => s,n(begin),GotoIf($["${CUT(DB(EXTUSER/{CODE}/${CUT(ARG1,-,${ITER})}/recording),=,3)}" != "always"]?continue)
exten => s,n,Set(TEXTEN=${CUT(ARG1,-,${ITER})})
exten => s,n,Noop(Recording enable for ${TEXTEN})
exten => s,n,Set({CODE}_CALLFILENAME=g${TEXTEN}-${STRFTIME(${EPOCH},,%Y%m%d-%H%M%S)}-${UNIQUEID})
exten => s,n,Goto(record)
exten => s,n(continue),Set(ITER=$[${ITER}+1])
exten => s,n,GotoIf($[${ITER}<=${LOOPCNT}]?begin)
exten => s,n(OUT),GotoIf($["${ARG2}"="IN"]?IN)
exten => s,n,ExecIf($["${CUT(DB(EXTUSER/{CODE}/${ARG1}/recording),\\\|,1):4}" != "always"]?MacroExit())
exten => s,n,Noop(Recording enable for ${ARG1})
exten => s,n,Set({CODE}_CALLFILENAME=OUT${ARG1}-${STRFTIME(${EPOCH},,%Y%m%d-%H%M%S)}-${UNIQUEID})
exten => s,n,Goto(record)
exten => s,n(IN),ExecIf($["${CUT(DB(EXTUSER/{CODE}/${ARG1}/recording),\\\|,2):3}" != "always"]?MacroExit())
exten => s,n,Noop(Recording enable for ${ARG1})
exten => s,n,Set({CODE}_CALLFILENAME=${STRFTIME(${EPOCH},,%Y%m%d-%H%M%S)}-${UNIQUEID})
exten => s,n,ExecIf($["${{CODE}_MIXMON_DIR}"=""]?Set({CODE}_MIXMON_DIR=${MIXMON_DIR}{DOMAIN}/))
exten => s,n,Set(AUDIOHOOK_INHERIT(MixMonitor)=yes) ; soluciona problema de perdida de graciones en transferencias
exten => s,n,ExecIf($["${{CODE}_MIXMON_FORMAT}"=""]?Set({CODE}_MIXMON_FORMAT}=wav)
exten => s,n,ExecIf($["${{CODE}_MIXMON_FORMAT}"="wav49"]?Set({CODE}_MIXMON_FORMAT}=WAV))
exten => s,n(record),MixMonitor(${{CODE}_MIXMON_DIR}${{CODE}_CALLFILENAME}.${{CODE}_MIXMON_FORMAT},a,${{CODE}_MIXMON_POST})
exten => s,n,Set(CDR(userfield)=audio:${{CODE}_MIXMON_DIR}${{CODE}_CALLFILENAME}.${{CODE}_MIXMON_FORMAT})
exten => s,n,MacroExit()


[{CODE}-ext-did-catchall]
include => ext-did-catchall-custom
exten => s,1,Noop(No DID or CID Match)
exten => s,n(a2),Answer
exten => s,n,Set(CDR(organization_domain)={DOMAIN})
exten => s,n,Wait(2)
exten => s,n,Playback(ss-noservice)
exten => s,n,Hangup
exten => _.,1,Set(__FROM_DID=${EXTEN})
exten => _.,n,Noop(Received an unknown call with DID set to ${EXTEN})
exten => _.,n,Goto(s,a2)
exten => h,1,Hangup

; end of [ext-did-catchall]


[{CODE}-app-blackhole]
include => {CODE}-app-blackhole-custom
exten => hangup,1,Noop(Blackhole Dest: Hangup)
exten => hangup,n,Set(CDR(organization_domain)={DOMAIN})
exten => hangup,n,Hangup
exten => zapateller,1,Noop(Blackhole Dest: Play SIT Tone)
exten => zapateller,n,Answer
exten => zapateller,n,Set(CDR(organization_domain)={DOMAIN})
exten => zapateller,n,Zapateller()
exten => musiconhold,1,Noop(Blackhole Dest: Put caller on hold forever)
exten => musiconhold,n,Answer
exten => musiconhold,n,Set(CDR(organization_domain)={DOMAIN})
exten => musiconhold,n,MusicOnHold()
exten => congestion,1,Noop(Blackhole Dest: Congestion)
exten => congestion,n,Answer
exten => congestion,n,Set(CDR(organization_domain)={DOMAIN})
exten => congestion,n,Playtones(congestion)
exten => congestion,n,Congestion(20)
exten => congestion,n,Hangup
exten => busy,1,Noop(Blackhole Dest: Busy)
exten => busy,n,Answer
exten => busy,n,Set(CDR(organization_domain)={DOMAIN})
exten => busy,n,Playtones(busy)
exten => busy,n,Busy(20)
exten => busy,n,Hangup
exten => ring,1,Noop(Blackhole Dest: Ring)
exten => ring,n,Answer
exten => ring,n,Set(CDR(organization_domain)={DOMAIN})
exten => ring,n,Playtones(ring)
exten => ring,n,Wait(300)
exten => ring,n,Hangup

; end of [{CODE}-app-blackhole]


[{CODE}-bad-number]
include => {CODE}-bad-number-custom
exten => _X.,1,ResetCDR()
exten => _X.,n,NoCDR()
exten => _X.,n,Progress
exten => _X.,n,Wait(1)
exten => _X.,n,Progress
exten => _X.,n,Playback(silence/1&cannot-complete-as-dialed&check-number-dial-again,noanswer)
exten => _X.,n,Wait(1)
exten => _X.,n,Congestion(20)
exten => _X.,n,Hangup

; end of [{CODE}-bad-number]


;------------------------------------------------------------------------
; [macro-confirm]
;------------------------------------------------------------------------
; CONTEXT:      macro-confirm
; PURPOSE:      added default message if none supplied
;
; Follom-Me and Ringgroups provide an option to supply a message to be
; played as part of the confirmation. These changes have added a default
; message if none is supplied.
;
;------------------------------------------------------------------------
[macro-{CODE}-confirm]
include => macro-{CODE}-confirm-custom
exten => s,1,Set(LOOPCOUNT=0)
exten => s,n,Set(__MACRO_RESULT=ABORT)
exten => s,n,Set(MSG1=${IF($["foo${ARG1}" != "foo"]?${ARG1}:"incoming-call-1-accept-2-decline")})
exten => s,n(start),Background(${MSG1},m,${CHANNEL(language)},macro-{CODE}-confirm)
exten => s,n,Read(INPUT,,1,,,4)
exten => s,n,GotoIf($[${LEN(${INPUT})} > 0]?${INPUT},1:t,1)
exten => 1,1,GotoIf($["${DB_EXISTS(RG/{CODE}/${ARG3}/${UNIQCHAN})}" = "0"]?toolate,1)
exten => 1,n,Noop(Deleting: RG/{CODE}/${ARG3}/${UNIQCHAN} ${DB_DELETE(RG/{CODE}/${ARG3}/${UNIQCHAN})})
exten => 1,n,Noop(Deleting: ${BLKVM_OVERRIDE} ${DB_DELETE(${BLKVM_OVERRIDE})})
exten => 1,n,Set(__MACRO_RESULT=)
exten => 1,n(exitopt1),MacroExit()
exten => 2,1,Goto(noanswer,1)
exten => 3,1,SayDigits(${CALLCONFIRMCID})
exten => 3,n,GotoIf($["${DB_EXISTS(RG/{CODE}/${ARG3}/${UNIQCHAN})}" = "0"]?toolate,1:s,start)
exten => t,1,GotoIf($["${DB_EXISTS(RG/{CODE}/${ARG3}/${UNIQCHAN})}" = "0"]?toolate,1)
exten => t,n,Set(LOOPCOUNT=$[ ${LOOPCOUNT} + 1 ])
exten => t,n,GotoIf($[ ${LOOPCOUNT} < 5 ]?s,start:noanswer,1)
exten => _X,1,Background(invalid,m,${CHANNEL(language)},macro-{CODE}-confirm)
exten => _X,n,GotoIf($["${DB_EXISTS(RG/{CODE}/${ARG3}/${UNIQCHAN})}" = "0"]?toolate,1)
exten => _X,n,Set(LOOPCOUNT=$[ ${LOOPCOUNT} + 1 ])
exten => _X,n,GotoIf($[ ${LOOPCOUNT} < 5 ]?s,start:noanswer,1)
exten => noanswer,1,Set(__MACRO_RESULT=ABORT)
exten => noanswer,n(exitnoanswer),MacroExit()
exten => toolate,1,Set(MSG2=${IF($["foo${ARG2}" != "foo"]?${ARG2}:"incoming-call-no-longer-avail")})
exten => toolate,n,Playback(${MSG2})
exten => toolate,n,Set(__MACRO_RESULT=ABORT)
exten => toolate,n(exittoolate),MacroExit()
exten => h,1,Macro({CODE}-hangupcall,)

; end of [{CODE}-macro-confirm]


;------------------------------------------------------------------------
; [macro-auto-confirm]
;------------------------------------------------------------------------
; This macro is called from ext-local-confirm to auto-confirm a call so that other extensions
; are aware that the call has been answered.
;
;------------------------------------------------------------------------
[macro-{CODE}-auto-confirm]
include => macro-{CODE}-auto-confirm-custom
exten => s,1,Set(__MACRO_RESULT=)
exten => s,n,Noop(Deleting: ${BLKVM_OVERRIDE} ${DB_DELETE(${BLKVM_OVERRIDE})})
exten => s,n,Noop(Deleting: RG/{CODE}/${ARG1}/${UNIQCHAN} ${DB_DELETE(RG/{CODE}/${ARG1}/${UNIQCHAN})})

; end of [macro-{CODE}-auto-confirm]


;------------------------------------------------------------------------
; [macro-auto-blkvm]
;------------------------------------------------------------------------
; This macro is called for any extension dialed form a queue, ringgroup
; or followme, so that the answering extension can clear the voicemail block
; override allow subsequent transfers to properly operate.
;
;------------------------------------------------------------------------
[macro-{CODE}-auto-blkvm]
include => macro-{CODE}-auto-blkvm-custom
exten => s,1,Set(__MACRO_RESULT=)
exten => s,n,Noop(Deleting: ${BLKVM_OVERRIDE} ${DB_DELETE(${BLKVM_OVERRIDE})})

; end of [macro-{CODE}-auto-blkvm]


;------------------------------------------------------------------------
; [sub-pincheck]
;------------------------------------------------------------------------
; This subroutine checks the pincode and then resets the CDR from that point
; if the pincode passes. This way the billsec and duration fields are set
; properly for pin dialing.
;
; ${ARG3} is the pincode if this was called, used by dialout-trunk, dialout-enum
; and dialout-dundi
;
;------------------------------------------------------------------------
[{CODE}-sub-pincheck]
include => {CODE}-sub-pincheck-custom
exten => s,1,Authenticate(${ARG3},)
exten => s,n,ResetCDR()
exten => s,n,Set(CDR(organization_domain)={DOMAIN})
exten => s,n,Return()
; end of [{CODE}-sub-pincheck]


; contexto llamado desde macro-{CODE}-dialout-trunk
; el proposito del mismo es en caso que la truncal tenga una condicion
; de maximo numero de llamadas por periodo de tiempo chequear que se cumpla
; con la condicion antes de permitir la salida del mismo
; ${ARG1}=TRUNK ID
[{CODE}-trunk-count-by-time]
exten => s,1,Noop(Verifing max channels by time)
exten => s,n,Set(RES_COUNT_TIME=)
exten => s,n,GotoIf($["${ARG1}" = ""]?fin)
exten => s,n,GotoIf($["${DB(TRUNK/${ARG1}/COUNT_TIME/BLOCK)}" = "true"]?blocked)
; deben estar seteados estos datos para poder hacer las validaciones respectivas
exten => s,n,GotoIf($["${DB_EXISTS(TRUNK/${ARG1}/COUNT_TIME/PERIOD)}"!="1" | "${DB_EXISTS(TRUNK/${ARG1}/COUNT_TIME/MAX)}"!="1" | "${DB_EXISTS(TRUNK/${ARG1}/COUNT_TIME/START_TIME)}"!="1"]?fin)
exten => s,n,Set(CURRENT_T=${STRFTIME(${EPOCH},,%s)})
exten => s,n,Set(ELAPSED_T=${MATH(${CURRENT_T}-${DB(TRUNK/${ARG1}/COUNT_TIME/START_TIME)},int)})
exten => s,n,Set(CURRENT_P=${IF(["${DB_EXISTS(TRUNK/${ARG1}/COUNT_TIME/NUM_PERIOD)}"="1"]?${DB(TRUNK/${ARG1}/COUNT_TIME/NUM_PERIOD)}:0)})
; obtenemos el numero de periodos transcurridos desde que se creo la regla hasta ahora
exten => s,n,Set(NUM_PERIOD=${MATH(${ELAPSED_T}/${DB(TRUNK/${ARG1}/COUNT_TIME/PERIOD)},int)})
exten => s,n,GotoIf($[${NUM_PERIOD}>${CURRENT_P}]?restart:check)
;verificamos si se alcanzo el maximo numero de llamadas por la truncal
exten => s,n(check),Set(COUNT_CALLS=${IF(["${DB_EXISTS(TRUNK/${ARG1}/COUNT_TIME/COUNT)}"="1"]?${DB(TRUNK/${ARG1}/COUNT_TIME/COUNT)}:0)})
exten => s,n,GotoIf($[${MATH(${COUNT_CALLS}+1),int}>${DB(TRUNK/${ARG1}/COUNT_TIME/MAX)}]?blocked)
exten => s,n,Set(DB(TRUNK/${ARG1}/COUNT_TIME/COUNT)=${MATH(${COUNT_CALLS}+1,int)})
exten => s,n,Goto(fin)
;reinacionamos el contador de llmadas por la truncal
exten => s,n(restart),Set(DB(TRUNK/${ARG1}/COUNT_TIME/NUM_PERIOD)=${NUM_PERIOD})
exten => s,n,Set(DB(TRUNK/${ARG1}/COUNT_TIME/COUNT)=1)
exten => s,n,Goto(fin)
;set in ASTDB bloked true to prevent more calls go out for thus trunk
exten => s,n(blocked),Set(DB(TRUNK/${ARG1}/COUNT_TIME/BLOCK)=true)
exten => s,n,Set(NUM_FAIL=${IF($["${DB_EXISTS(TRUNK/${ARG1}/COUNT_TIME/NUM_FAIL)}"="1"]?${MATH(${DB(TRUNK/${ARG1}/COUNT_TIME/NUM_FAIL)}+1,int)}:1)})
exten => s,n,Set(DB(TRUNK/${ARG1}/COUNT_TIME/NUM_FAIL)=${NUM_FAIL})
exten => s,n,Set(RES_COUNT_TIME=block)
exten => s,n(fin),Return(${RES_COUNT_TIME})
; [{CODE}-trunk-count-by-time]


; dialout using a trunk, using pattern matching (don't strip any prefix)
; arg1 = trunk number, arg2 = number, arg3 = route password
;
; MODIFIED (PL)
;
; Modified both Dial() commands to include the new TRUNK_OPTIONS from the general
; screen of AMP

[macro-{CODE}-dialout-trunk]
include => macro-{CODE}-dialout-trunk-custom
exten => s,1,Set(DIAL_TRUNK=${ARG1})
exten => s,n,GotoIf($["${DB_EXISTS(TRUNK/${DIAL_TRUNK}/OUT)}"!="1"]?noexist,1) ; no existe dicha truncal
exten => s,n,Set(OUT_${DIAL_TRUNK}=${DB_RESULT})
exten => s,n,GosubIf($[$["${ARG3}" != ""] & $["${DB(EXTUSER/{CODE}/${EXTUSER}/pinless)}" != "NOPASSWD"]]?{CODE}-sub-pincheck,s,1)
exten => s,n,GotoIf($["x${DB(TRUNK/${DIAL_TRUNK}/OUTDISABLE)}" = "xon"]?disabletrunk,1)
exten => s,n,Set(DIAL_NUMBER=${ARG2}) ; fixlocalprefix depends on this
exten => s,n,Set(DIAL_TRUNK_OPTIONS=${{CODE}_DIAL_OPTIONS}) ; will be reset to TRUNK_OPTIONS if not intra-company
exten => s,n,Set(OUTBOUND_GROUP=OUT_${DIAL_TRUNK})
exten => s,n,GotoIf($["${DB_EXISTS(TRUNK/${DIAL_TRUNK}/OUTMAXCHANS)}" != "1"]?nomax) 
exten => s,n,GotoIf($[ ${GROUP_COUNT(OUT_${DIAL_TRUNK})} >= ${DB_RESULT} ]?chanfull) 
exten => s,n(nomax),Gosub({CODE}-trunk-count-by-time,s,1(${DIAL_TRUNK})) ; security parameter max call by time 
exten => s,n,GotoIf($["x${GOSUB_RETVAL}" = "xblock"]?maxbytime)
exten => s,n,GotoIf($["${INTRACOMPANYROUTE}" = "YES"]?skipoutcid) ;Set to YES if treated like internal
exten => s,n,Set(DIAL_TRUNK_OPTIONS=${{CODE}_TRUNK_OPTIONS})
exten => s,n,Macro({CODE}-outbound-callerid,${DIAL_TRUNK})
exten => s,n(skipoutcid),GosubIf($["${DB(TRUNK/${DIAL_TRUNK}/PREFIX_TRUNK)}" = "1"]?sub-flp-${DIAL_TRUNK},s,1) ; this sets DIAL_NUMBER to the proper dial string for this trunk
exten => s,n,Set(OUTNUM=${DB(TRUNK/${DIAL_TRUNK}/OUTPREFIX)}${DIAL_NUMBER}) ; final number to dial
exten => s,n,Set(CDR(toout)=1) ; se marcar que la llamada es de salida
exten => s,n,Set(custom=${CUT(OUT_${DIAL_TRUNK},/,1)}) ; Custom trunks are prefixed with "CUSTOM/"
exten => s,n,ExecIf($[$["${MOHCLASS}" != "default"] & $["${MOHCLASS}" !=""] ]?Set(DIAL_TRUNK_OPTIONS=M(setmusic^${MOHCLASS})${DIAL_TRUNK_OPTIONS}))
; This macro call will always be blank and is provided as a hook for customization required prior to making a call
; such as adding SIP header information or other requirements. All the channel variables from above are present
exten => s,n(gocall),Macro({CODE}-dialout-trunk-predial-hook,)
exten => s,n,GotoIf($["${PREDIAL_HOOK_RET}" = "BYPASS"]?bypass,1)
; Context salida-check and allow-out are found in extensions_additionals
exten => s,n,Gosub(salida-check,s,1({CODE},{DOMAIN},${DIAL_NUMBER},${OUT_${DIAL_TRUNK}})) ; this if used to forward the call in case it was necesary
exten => s,n,GotoIf($["x${GOSUB_RETVAL}" != "xcontinue"]?h,1)
exten => s,n,Gosub(allow-out,s,1({DOMAIN},${DIAL_TRUNK})) ; to verify if this organization can dial throughout this trunk
exten => s,n,GotoIf($["x${GOSUB_RETVAL}" = "xnoallow"]?noallow)
exten => s,n,Noop('CALLERID OUTBOUND: ${CALLERID(all)}')
exten => s,n,Set(ANI_TRUNK=${TRUNK_GETANI({DOMAIN},${DIAL_TRUNK})})
exten => s,n,Noop('PREFIX ANI + CALLERID OUTBOUND: ${ANI_TRUNK}${CALLERID(number)}')
exten => s,n,Set(CALLERID(number)=${ANI_TRUNK}${CALLERID(number)})
exten => s,n,Noop('NEW CALLERID OUTBOUND: ${CALLERID(all)}')
exten => s,n,GotoIf($["${custom}" = "CUSTOM"]?customtrunk) ; it is made to dial with custom trunks
exten => s,n,Dial(${OUT_${DIAL_TRUNK}}/${OUTNUM},300,${DIAL_TRUNK_OPTIONS})
exten => s,n,Noop(Dial failed for some reason with DIALSTATUS = ${DIALSTATUS} and HANGUPCAUSE = ${HANGUPCAUSE})
exten => s,n,GotoIf($["${ARG4}" = "on"]?continue,1:s-${DIALSTATUS},1)
exten => s,n(customtrunk),Set(pre_num=${CUT(OUT_${DIAL_TRUNK},$,1)})
exten => s,n,Set(the_num=${CUT(OUT_${DIAL_TRUNK},$,2)}) ; this is where we expect to find string OUTNUM
exten => s,n,Set(post_num=${CUT(OUT_${DIAL_TRUNK},$,3)})
exten => s,n,GotoIf($["${the_num}" = "OUTNUM"]?outnum:skipoutnum) ;if we didn't find "OUTNUM", then skip to Dial
exten => s,n(outnum),Set(the_num=${OUTNUM}) ; replace "OUTNUM" with the actual number to dial
exten => s,n(skipoutnum),Dial(${pre_num:7}${the_num}${post_num},300,${DIAL_TRUNK_OPTIONS})
exten => s,n,Noop('Dial failed for some reason with DIALSTATUS = ${DIALSTATUS} and HANGUPCAUSE = ${HANGUPCAUSE}')
exten => s,n,GotoIf($["${ARG4}" = "on"]?continue,1:s-${DIALSTATUS},1)
exten => s,n(chanfull),Noop(max channels used up)
exten => s,n,MacroExit()
exten => s,n(maxbytime),Noop(max channels in a period of time reached)
exten => s,n,MacroExit()
exten => s-BUSY,1,Noop(Dial failed due to trunk reporting BUSY - giving up)
exten => s-BUSY,n,Playtones(busy)
exten => s-BUSY,n,Busy(20)
exten => s-ANSWER,1,Noop(Call successfully answered - Hanging up now)
exten => s-ANSWER,n,Macro({CODE}-hangupcall,)
exten => s-NOANSWER,1,Noop(Dial failed due to trunk reporting NOANSWER - giving up)
exten => s-NOANSWER,n,Progress
exten => s-NOANSWER,n,Playback(number-not-answering,noanswer)
exten => s-NOANSWER,n,Congestion(20)
exten => s-INVALIDNMBR,1,Noop(Dial failed due to trunk reporting Address Incomplete - giving up)
exten => s-INVALIDNMBR,n,Progress
exten => s-INVALIDNMBR,n,Playback(ss-noservice,noanswer)
exten => s-INVALIDNMBR,n,Busy(20)
exten => s-CHANGED,1,Noop(Dial failed due to trunk reporting Number Changed - giving up)
exten => s-CHANGED,n,Playtones(busy)
exten => s-CHANGED,n,Busy(20)
exten => _s-.,1,Set(RC=${IF($[${ISNULL(${HANGUPCAUSE})}]?0:${HANGUPCAUSE})})
exten => _s-.,n,Goto(${RC},1)
exten => 17,1,Goto(s-BUSY,1)
exten => 18,1,Goto(s-NOANSWER,1)
exten => 22,1,Goto(s-CHANGED,1)
exten => 23,1,Goto(s-CHANGED,1)
exten => 28,1,Goto(s-INVALIDNMBR,1)
exten => _X,1,Goto(continue,1)
exten => _X.,1,Goto(continue,1)
exten => continue,1,GotoIf($["${OUTFAIL_${ARG1}}" = ""]?noreport)
exten => continue,n,AGI(${OUTFAIL_${ARG1}})
exten => continue,n(noreport),Noop(TRUNK Dial failed due to ${DIALSTATUS} HANGUPCAUSE: ${HANGUPCAUSE} - failing through to other trunks)
exten => continue,n,Set(CALLERID(number)=${EXTUSER})
exten => disabletrunk,1,Noop(TRUNK: ${OUT_${DIAL_TRUNK}} DISABLED - falling through to next trunk)
exten => disabletrunk,n,MacroExit()
exten => bypass,1,Noop(TRUNK: ${OUT_${DIAL_TRUNK}} BYPASSING because dialout-trunk-predial-hook)
exten => bypass,n,MacroExit()
exten => noexist,1,Noop(TRUNK: with id ${DIAL_TRUNK} doesn't exist)
exten => noexist,n,MacroExit()
exten => noallow,1,Noop(TRUNK: with id ${DIAL_TRUNK} isn't allow as out trunk for organization with domain {DOMAIN})
exten => noallow,n,MacroExit()
exten => h,1,Macro({CODE}-hangupcall,)

; end of [macro-{CODE}-dialout-trunk]

[macro-{CODE}-outisbusy]
include => macro-{CODE}-outisbusy-custom
exten => s,1,Progress
exten => s,n,GotoIf($["${EMERGENCYROUTE}" = "YES"]?emergency,1)
exten => s,n,GotoIf($["${INTRACOMPANYROUTE}" = "YES"]?intracompany,1)
exten => s,n,GotoIf($["${HANGUPCAUSE}" = "1"]?unallocated,1)
exten => s,n,GotoIf($["${HANGUPCAUSE}" = "18"]?noanswer,1)
exten => s,n,GotoIf($["${HANGUPCAUSE}" = "19"]?noanswer,1)
exten => s,n,Playback(all-circuits-busy-now&pls-try-call-later, noanswer)
exten => s,n,Congestion(20)
exten => s,n,Hangup
exten => noanswer,1,Playback(number-not-answering, noanswer)
exten => noanswer,n,Congestion(20)
exten => noanswer,n,Hangup
exten => unallocated,1,Playback(the-number-u-dialed&no-longer-in-service, noanswer)
exten => unallocated,n,Congestion(20)
exten => unallocated,n,Hangup
exten => intracompany,1,Playback(all-circuits-busy-now&pls-try-call-later, noanswer)
exten => intracompany,n,Congestion(20)
exten => intracompany,n,Hangup
exten => emergency,1,Playback(all-circuits-busy-now&pls-try-call-later)
exten => emergency,n,Congestion(20)
exten => emergency,n,Hangup


; overrides callerid out trunks
; arg1 is trunk
; macro-user-callerid should be called _before_ using this macro
[macro-{CODE}-outbound-callerid]
include => macro-{CODE}-outbound-callerid-custom
exten => s,1,ExecIf($["${CALLINGPRES_SV}" != ""]?Set(CALLERPRES()=${CALLINGPRES_SV}))
exten => s,n,ExecIf($["${REALCALLERIDNUM:1:2}" = ""]?Set(REALCALLERIDNUM=${CALLERID(number)}))
exten => s,n,Set(OUTKEEPCID=${DB(TRUNK/${ARG1}/OUTKEEPCID)})
exten => s,n(start),GotoIf($[ $["${REALCALLERIDNUM}" = ""] | $["${KEEPCID}" != "TRUE"] | $["${OUTKEEPCID}" = "on"] ]?normcid)
exten => s,n,Set(USEROUTCID=${REALCALLERIDNUM})
exten => s,n,GotoIf($["foo${DB(EXTUSER/{CODE}/${REALCALLERIDNUM}/device)}" = "foo"]?bypass)
exten => s,n(normcid),Set(USEROUTCID=${DB(EXTUSER/{CODE}/${EXTUSER}/outboundcid)})
exten => s,n(bypass),Set(EMERGENCYCID=${DB(DEVICE/{CODE}/${REALCALLERIDNUM}_{CODE}/emergency_cid)})
exten => s,n,Set(TRUNKOUTCID=${DB(TRUNK/${ARG1}/OUTCID)})
exten => s,n,GotoIf($["${EMERGENCYROUTE:1:2}" = "" | "${EMERGENCYCID:1:2}" = ""]?trunkcid)
exten => s,n,Set(CALLERID(all)=${EMERGENCYCID})
exten => s,n(exit),MacroExit()
exten => s,n(trunkcid),ExecIf($[${LEN(${TRUNKOUTCID})} != 0]?Set(CALLERID(all)=${TRUNKOUTCID}))
exten => s,n(usercid),ExecIf($[${LEN(${USEROUTCID})} != 0]?Set(CALLERID(all)=${USEROUTCID}))
; TRUNKCIDOVERRIDE is used by followme and can be used by other functions. It forces the specified 
; CID except for the case of an Emergency CID on an Emergency Route
exten => s,n,ExecIf($[${LEN(${TRUNKCIDOVERRIDE})}!=0]?Set(CALLERID(all)=${TRUNKCIDOVERRIDE}))
exten => s,n,ExecIf($[${DB_EXISTS(TRUNK/${ARG1}/FORCEDOUTCID)}]?Set(CALLERID(all)=${DB_RESULT}))
exten => s,n(hidecid),ExecIf($["${CALLERID(name)}"="hidden"]?Set(CALLERPRES()=prohib_passed_screen))
exten => s,n,ExecIf($["${OUTKEEPCID}" = "cnum"]'?Set(CALLERID(name)=''))

; end of [macro-{CODE}-outbound-callerid]


[{CODE}-from-dahdi]
include => {CODE}-from-dahdi-custom
exten => _X.,1,Set(DID=${EXTEN})
exten => _X.,n,Goto(s,1)
exten => s,1,Noop(Entering from-dahdi with DID == ${DID})
exten => s,n,Ringing()
exten => s,n,Set(DID=${IF($["${DID}"= ""]?s:${DID})})
exten => s,n,Noop(DID is now ${DID})
exten => s,n,GotoIf($["${CHANNEL:0:5}"="DAHDI"]?dahdiok:checkzap)
exten => s,n(checkzap),GotoIf($["${CHANNEL:0:3}"="Zap"]?zapok:neither)
exten => s,n(neither),Goto({CODE}-from-pstn,${DID},1)
exten => s,n,Macro({CODE}-hangupcall)
exten => s,n(dahdiok),Noop(Is a DAHDI Channel)
exten => s,n,Set(CHAN=${CHANNEL:6})
exten => s,n,Set(CHAN=${CUT(CHAN,-,1)})
exten => s,n,Macro({CODE}-from-dahdi-${CHAN},${DID},1)
exten => s,n,Noop(Returned from Macro from-dahdi-${CHAN})
exten => s,n,Goto({CODE}-from-pstn,${DID},1)
exten => s,n(zapok),Noop(Is a Zaptel Channel)
exten => s,n,Set(CHAN=${CHANNEL:4})
exten => s,n,Set(CHAN=${CUT(CHAN,-,1)})
exten => s,n,Macro({CODE}-from-dahdi-${CHAN},${DID},1)
exten => s,n,Noop(Returned from Macro {CODE}-from-dahdi-${CHAN})
exten => s,n,Goto({CODE}-from-pstn,${DID},1)

; end of [from-dahdi]


[macro-{CODE}-user-callerid]
include => macro-{CODE}-user-callerid-custom
exten => s,1,Set(EXTUSER=${IF($["foo${EXTUSER}" = "foo"]?${CALLERID(number)}:${EXTUSER})})
exten => s,n,GotoIf($["${CHANNEL:0:5}" = "Local"]?report)
exten => s,n,ExecIf($["${REALCALLERIDNUM:1:2}" = ""]?Set(REALCALLERIDNUM=${CALLERID(number)}))
exten => s,n,Set(EXTUSER=${DB(DEVICE/{CODE}/${REALCALLERIDNUM}_{CODE}/exten)})
exten => s,n,Set(EXTUSERCIDNAME=${DB(EXTUSER/{CODE}/${EXTUSER}/cidname)})
exten => s,n,GotoIf($["x${EXTUSERCIDNAME:1:2}" = "x"]?report)
exten => s,n,Set(EXTUSERCID=${IF($["${DB_EXISTS(EXTUSER/{CODE}/${EXTUSER}/cidnum)}" = "1"]?${DB_RESULT}:${EXTUSER})})
exten => s,n,Set(CALLERID(all)="${EXTUSERCIDNAME}" <${EXTUSERCID}>)
exten => s,n,ExecIf($["${{CODE}_LANGUAGE}" != ""]?Set(CHANNEL(language)=${{CODE}_LANGUAGE}))
exten => s,n,ExecIf($["${DB(EXTUSER/{CODE}/${EXTUSER}/language)}" != ""]?Set(CHANNEL(language)=${DB(EXTUSER/{CODE}/${EXTUSER}/language)}))
exten => s,n(report),GotoIf($[ "${ARG1}" = "SKIPTTL" ]?continue)
exten => s,n(report2),Set(__TTL=${IF($["foo${TTL}" = "foo"]?64:$[ ${TTL} - 1 ])})
exten => s,n,GotoIf($[ ${TTL} > 0 ]?continue)
exten => s,n,Wait(${{CODE}_RINGTIMER})
exten => s,n,Answer
exten => s,n,Wait(2)
exten => s,n,Playback(im-sorry&an-error-has-occured&with&call-forwarding)
exten => s,n,Macro({CODE}-hangupcall,)
exten => s,n,Congestion(20)
exten => s,n(continue),Set(CALLERID(number)=${CALLERID(number):0:40})
exten => s,n,Set(CALLERID(name)=${CALLERID(name):0:40})
exten => s,n,Noop(Using CallerID ${CALLERID(all)})
exten => h,1,Macro({CODE}-hangupcall,)

; end of [macro-{CODE}-user-callerid]


; se usa para llamar a un voicemail especifico
[{CODE}-vm-callme]
include => {CODE}-vm-callme-custom
exten => s,1,Answer
exten => s,n,Set(CDR(organization_domain)={DOMAIN})
exten => s,n,Wait(1)
exten => s,n(repeat),Background(${MSG}&silence/2&vm-repeat&vm-starmain)
exten => s,n,WaitExten(15,)
exten => 5,1,Goto(s,repeat)
exten => #,1,Playback(vm-goodbye)
exten => #,n,Hangup
exten => *,1,Macro({CODE}-get-vmcontext,${MBOX})
exten => *,n,VoiceMailMain(${MBOX}@${VMCONTEXT},s)
exten => i,1,Playback(pm-invalid-option)
exten => i,n,Goto(s,repeat)
exten => t,1,Playback(vm-goodbye)
exten => t,n,Hangup
exten => h,1,Hangup
exten => s-ANSWER,1,Noop(Call successfully answered - Hanging up now)
exten => s-ANSWER,n,Macro({CODE}-hangupcall,)

; end of [{CODE}-vm-callme]


;------------------------------------------------------------------------
; [macro-vm]
;------------------------------------------------------------------------
; CONTEXT:      macro-vm
; PURPOSE:      call voicemail system and extend with personal ivr
;
; Under normal use, this macro will call the voicemail system with the extension and
; desired greeting mode of busy, unavailable or as specified with direct voicemail
; calls (usually unavailable) when entered from destinations.
;
; The voicemail system's two greetings have been 'hijacked' as follows to extend the
; system by giving the option of a private 'ivr' for each voicemail user. The following
; applies to both the busy and unavailable modes of voicemail and can be applied to one
; or both, and differently.
; ARG1 - extension
; ARG2 - DIRECTDIAL/BUSY
; ARG3 - RETURN makes macro return, otherwise hangup
;------------------------------------------------------------------------

[macro-{CODE}-vm]
include => macro-{CODE}-vm-custom
exten => s,1,ExecIf($["${DB(EXTUSER/{CODE}/${ARG1}/voicemail)}"="novm"]?Goto(exit-NOVM,1))
exten => s,n,Macro({CODE}-user-callerid,SKIPTTL)
exten => s,n,Set(VMGAIN=${IF($["foo${{CODE}_VM_GAIN}"!="foo"]?"g(${{CODE}_VM_GAIN})":"")})
exten => s,n,GotoIf($["${BLKVM_OVERRIDE}"=""]?vmx,1)
exten => s,n,GotoIf($["foo${DB(${BLKVM_OVERRIDE})}" != "fooTRUE"]?vmx,1))
exten => s,n,Noop(CAME FROM: ${NODEST} - Blocking VM cause of key: ${DB(BLKVM_OVERRIDE)})
exten => s,n,Hangup
exten => vmx,1,Set(MEXTEN=${ARG1})
exten => vmx,n,Set(MMODE=${ARG2})
exten => vmx,n,Set(RETVM=${ARG3})
exten => vmx,n,Set(MODE=${IF($["${MMODE}"="BUSY"]?busy:unavail)})
exten => vmx,n,GotoIf($["${DB_EXISTS(EXTUSER/{CODE}/${MEXTEN}/vmx/vmxopts/timeout)}" = "0"]?chknomsg)
exten => vmx,n,Set({CODE}_VM_OPTS=${DB_RESULT})
exten => vmx,n(chknomsg),GotoIf($["${MMODE}"="NOMESSAGE"]?s-${MMODE},1)
exten => vmx,n,GotoIf($["${MMODE}" != "DIRECTDIAL"]?notdirect)
exten => vmx,n,Set(MODE=${IF($["${REGEX("[b]" ${VM_DDTYPE})}" = "1"]?busy:${MODE})})
exten => vmx,n(notdirect),Noop(Checking if ext ${MEXTEN} is enabled: ${DB(EXTUSER/{CODE}/${MEXTEN}/vmx/${MODE}/state)})
exten => vmx,n,GotoIf($["${DB(EXTUSER/{CODE}/${MEXTEN}/vmx/${MODE}/state)}" != "enabled"]?s-${MMODE},1)
exten => vmx,n,Macro({CODE}-get-vmcontext,${MEXTEN})
exten => vmx,n,GotoIf($[(${STAT(f,${ASTSPOOLDIR}/voicemail/${VMCONTEXT}/${MEXTEN}/temp.wav)} = 1) || (${STAT(f,${ASTSPOOLDIR}/voicemail/${VMCONTEXT}/${MEXTEN}/temp.WAV)} = 1)]?tmpgreet)
exten => vmx,n,GotoIf($[(${STAT(f,${ASTSPOOLDIR}/voicemail/${VMCONTEXT}/${MEXTEN}/${MODE}.wav)} = 0) && (${STAT(f,${ASTSPOOLDIR}/voicemail/${VMCONTEXT}/${MEXTEN}/${MODE}.WAV)} = 0)]?nofile)
exten => vmx,n,Set(LOOPCOUNT=0)
exten => vmx,n(vmxanswer),Answer
exten => vmx,n(loopstart),Read(ACTION,${ASTSPOOLDIR}/voicemail/${VMCONTEXT}/${MEXTEN}/${MODE},1,skip,${{CODE}_VMX_REPEAT},${{CODE}_VMX_TIMEOUT})
exten => vmx,n,GotoIf($["${EXISTS(${ACTION})}" = "1"]?checkopt)
exten => vmx,n(noopt),Noop(Timeout: going to timeout dest)
exten => vmx,n,Set({CODE}_VMX_OPTS=${{CODE}_VMX_OPTS_TIMEOUT})
exten => vmx,n(dotime),Goto(${{CODE}_VMX_TIMEDEST_CONTEXT},${{CODE}_VMX_TIMEDEST_EXT},${{CODE}_VMX_TIMEDEST_PRI})
exten => vmx,n(checkopt),GotoIf($["${DB_EXISTS(EXTUSER/{CODE}/${MEXTEN}/vmx/${ACTION}/ext)}" = "1"]?doopt)
exten => vmx,n,GotoIf($["${ACTION}" = "0"]?o,1)
exten => vmx,n,GotoIf($["${ACTION}" = "*"]?adef,1)
exten => vmx,n,Set(LOOPCOUNT=$[${LOOPCOUNT} + 1])
exten => vmx,n,GotoIf($[${LOOPCOUNT} > ${{CODE}_VMX_LOOPS}]?toomany)
exten => vmx,n,Playback(pm-invalid-option&please-try-again)
exten => vmx,n,Goto(loopstart)
exten => vmx,n(toomany),Noop(Too Many invalid entries, got to invalid dest)
exten => vmx,n,Set({CODE}_VMX_OPTS=${{CODE}_VMX_OPTS_LOOPS})
exten => vmx,n,Goto(${{CODE}_VMX_LOOPDEST_CONTEXT},${{CODE}_VMX_LOOPDEST_EXT},${{CODE}_VMX_LOOPDEST_PRI})
exten => vmx,n(doopt),Noop(Got a valid option: ${DB(EXTUSER/{CODE}/${MEXTEN}/vmx/${ACTION}/ext)})
exten => vmx,n,Set({CODE}_VMX_EXT=${DB(EXTUSER/{CODE}/${MEXTEN}/vmx/${ACTION}/ext)})
exten => vmx,n,GotoIf($["${{CODE}_VMX_EXT}" != "dovm"]?getdest)
exten => vmx,n(vmxopts),Set({CODE}_VMX_OPTS=${{CODE}_VMX_OPTS_DOVM})
exten => vmx,n(vmxdovm),Goto(dovm,1)
exten => vmx,n(getdest),GotoIf($["${DB_EXISTS(EXTUSER/{CODE}/${MEXTEN}/vmx/${ACTION}/context)}" = "0"]?vmxpri)
exten => vmx,n,Set({CODE}_VMX_CONTEXT=${DB_RESULT})
exten => vmx,n(vmxpri),GotoIf($["${DB_EXISTS(EXTUSER/{CODE}/${MEXTEN}/vmx/${ACTION}/pri)}" = "0"]?vmxgoto)
exten => vmx,n,Set({CODE}_VMX_PRI=${DB_RESULT})
exten => vmx,n(vmxgoto),Goto(${{CODE}_VMX_CONTEXT},${{CODE}_VMX_EXT},${{CODE}_VMX_PRI})
exten => vmx,n(nofile),Noop(File for mode: ${MODE} does not exist, SYSTEMSTATUS: ${SYSTEMSTATUS}, going to normal voicemail)
exten => vmx,n,Goto(s-${MMODE},1)
exten => vmx,n(tmpgreet),Noop(Temporary Greeting Detected, going to normal voicemail)
exten => vmx,n,Goto(s-${MMODE},1)
exten => dovm,1,Noop(VMX Timeout - go to voicemail)
exten => dovm,n,VoiceMail(${MEXTEN}@${VMCONTEXT},${{CODE}_VMX_OPTS}${VMGAIN})
exten => dovm,n,Goto(exit-${VMSTATUS},1)
exten => s-BUSY,1,Noop(BUSY voicemail)
exten => s-BUSY,n,Macro({CODE}-get-vmcontext,${MEXTEN})
exten => s-BUSY,n,VoiceMail(${MEXTEN}@${VMCONTEXT},${{CODE}_VM_OPTS}b${VMGAIN})
exten => s-BUSY,n,Goto(exit-${VMSTATUS},1)
exten => s-NOMESSAGE,1,Noop(NOMESSAGE (beeb only) voicemail)
exten => s-NOMESSAGE,n,Macro({CODE}-get-vmcontext,${MEXTEN})
exten => s-NOMESSAGE,n,VoiceMail(${MEXTEN}@${VMCONTEXT},s${{CODE}_VM_OPTS}${VMGAIN})
exten => s-NOMESSAGE,n,Goto(exit-${VMSTATUS},1)
exten => s-DIRECTDIAL,1,Noop(DIRECTDIAL voicemail)
exten => s-DIRECTDIAL,n,Macro({CODE}-get-vmcontext,${MEXTEN})
exten => s-DIRECTDIAL,n,VoiceMail(${MEXTEN}@${VMCONTEXT},${{CODE}_VM_OPTS}${VM_DDTYPE}${VMGAIN})
exten => s-DIRECTDIAL,n,Goto(exit-${VMSTATUS},1)
exten => _s-.,1,Macro({CODE}-get-vmcontext,${MEXTEN})
exten => _s-.,n,VoiceMail(${MEXTEN}@${VMCONTEXT},${{CODE}_VM_OPTS}u${VMGAIN})
exten => _s-.,n,Goto(exit-${VMSTATUS},1)
exten => o,1,Playback(one-moment-please)
exten => o,n,GotoIf($["${DB_EXISTS(EXTUSER/{CODE}/${MEXTEN}/vmx/0/ext)}" = "0"]?doopdef)
exten => o,n,Set({CODE}_VMX_OPDEST_EXT=${DB_RESULT})
exten => o,n,GotoIf($["${DB_EXISTS(EXTUSER/{CODE}/${MEXTEN}/vmx/0/context)}" = "1"]?opcontext)
exten => o,n,Set(DB_RESULT=${{CODE}_VMX_CONTEXT})
exten => o,n(opcontext),Set({CODE}_VMX_OPDEST_CONTEXT=${DB_RESULT})
exten => o,n,GotoIf($["${DB_EXISTS(EXTUSER/{CODE}/${MEXTEN}/vmx/0/pri)}" = "1"]?oppri)
exten => o,n,Set(DB_RESULT=${{CODE}_VMX_PRI})
exten => o,n(oppri),Set({CODE}_VMX_OPDEST_PRI=${DB_RESULT})
exten => o,n,Goto(${{CODE}_VMX_OPDEST_CONTEXT},${{CODE}_VMX_OPDEST_EXT},${{CODE}_VMX_OPDEST_PRI})
exten => o,n(doopdef),GotoIf($["x${{CODE}_OPERATOR_XTN}"="x"]?nooper:{CODE}-from-internal,${{CODE}_OPERATOR_XTN},1)
exten => o,n(nooper),GotoIf($["x${FROM_DID}"="x"]?nodid)
exten => o,n,Dial(Local/${FROM_DID}@{CODE}-from-pstn,)
exten => o,n,Macro({CODE}-hangupcall,)
exten => o,n(nodid),Dial(Local/s@{CODE}-from-pstn,)
exten => o,n,Macro({CODE}-hangupcall,)
exten => a,1,Macro({CODE}-get-vmcontext,${MEXTEN})
exten => a,n,GotoIf($["${DB_EXISTS(EXTUSER/{CODE}/${MEXTEN}/vmx/*/ext)}" = "0"]?adef,1)
exten => a,n,Set({CODE}_VMX_ADEST_EXT=${DB_RESULT})
exten => a,n,GotoIf($["${DB_EXISTS(EXTUSER/{CODE}/${MEXTEN}/vmx/*/context)}" = "1"]?acontext)
exten => a,n,Set(DB_RESULT=${{CODE}_VMX_CONTEXT})
exten => a,n(acontext),Set({CODE}_VMX_ADEST_CONTEXT=${DB_RESULT})
exten => a,n,GotoIf($["${DB_EXISTS(EXTUSER/{CODE}/${MEXTEN}/vmx/*/pri)}" = "1"]?apri)
exten => a,n,Set(DB_RESULT=${{CODE}_VMX_PRI})
exten => a,n(apri),Set(VMX_ADEST_PRI=${DB_RESULT})
exten => a,n,Goto(${{CODE}_VMX_ADEST_CONTEXT},${{CODE}_VMX_ADEST_EXT},${{CODE}_VMX_ADEST_PRI})
exten => adef,1,VoiceMailMain(${MEXTEN}@${VMCONTEXT})
exten => adef,n,GotoIf($["${RETVM}" = "RETURN"]?exit-RETURN,1)
exten => adef,n,Hangup
exten => exit-FAILED,1,Playback(im-sorry&an-error-has-occured)
exten => exit-FAILED,n,GotoIf($["${RETVM}" = "RETURN"]?exit-RETURN,1)
exten => exit-FAILED,n,Hangup
exten => exit-SUCCESS,1,GotoIf($["${RETVM}" = "RETURN"]?exit-RETURN,1)
exten => exit-SUCCESS,n,Playback(goodbye)
exten => exit-SUCCESS,n,Hangup
exten => exit-USEREXIT,1,GotoIf($["${RETVM}" = "RETURN"]?exit-RETURN,1)
exten => exit-USEREXIT,n,Playback(goodbye)
exten => exit-USEREXIT,n,Hangup
exten => exit-NOVM,1,GotoIf($["${ARG3}" = "RETURN"]?exit-RETURN,1)
exten => exit-NOVM,n,Playback(silence/1&cannot-complete-as-dialed&check-number-dial-again,noanswer)
exten => exit-NOVM,n,Hangup
exten => exit-RETURN,1,Noop(Returning From Voicemail because macro)
exten => t,1,Hangup

; end of [macro-{CODE}-vm]


[macro-{CODE}-exten-vm]
include => macro-{CODE}-exten-vm-custom
exten => s,1,Macro({CODE}-user-callerid,)
exten => s,n,Set(RingGroupMethod=none)
exten => s,n,Set(VMBOX=${ARG1})
exten => s,n,GotoIf($["${VMBOX}"="novm"]?setextcall)
; comprobamos que realemente tenga el voicemail activo
exten => s,n,ExecIf($["${DB(EXTUSER/{CODE}/${VMBOX}/voicemail)}"="novm"]?Set(VMBOX=novm))
exten => s,n(setextcall),Set(__EXTTOCALL=${ARG2})
exten => s,n,Set(__PICKUPMARK=${ARG2})
exten => s,n,Set(CFUEXT=${DB(CFU/{CODE}/${EXTTOCALL})})
exten => s,n,Set(CFBEXT=${DB(CFB/{CODE}/${EXTTOCALL})})
exten => s,n,Set(RT=${IF($[$["${VMBOX}"!="novm"] | $["${CFUEXT}"!=""]]?${{CODE}_RINGTIMER}:"")})
exten => s,n(checkrecord),Macro({CODE}-record-enable,${EXTTOCALL},IN)
exten => s,n(macrodial),Macro({CODE}-dial-one,${RT},${{CODE}_DIAL_OPTIONS},${EXTTOCALL})
exten => s,n,GotoIf($["${VMBOX}"!="novm" & "${SCREEN}"!="" & "${DIALSTATUS}"="NOANSWER"]?exit)
exten => s,n,Set(SV_DIALSTATUS=${DIALSTATUS})
exten => s,n(calldocfu),GosubIf($[("${SV_DIALSTATUS}"="NOANSWER"|"${SV_DIALSTATUS}"="CHANUNAVAIL") & "${CFUEXT}"!="" & "${SCREEN}"=""]?docfu,1)
exten => s,n(calldocfb),GosubIf($["${SV_DIALSTATUS}"="BUSY" & "${CFBEXT}"!=""]?docfb,1)
exten => s,n,Set(DIALSTATUS=${SV_DIALSTATUS})
exten => s,n,Noop(Voicemail is '${VMBOX}')
exten => s,n,GotoIf($["${VMBOX}"="novm"]?s-${DIALSTATUS},1)
exten => s,n,Noop(Sending to Voicemail box ${EXTTOCALL})
exten => s,n,Macro({CODE}-vm,${VMBOX},${DIALSTATUS},${IVR_RETVM})
exten => docfu,1(docfu),Set(RTCFU=${IF($["${VMBOX}"!="novm"]?${{CODE}_RINGTIMER}:"")})
exten => docfu,n,Dial(Local/${CFUEXT}@{CODE}-from-internal/n,${RTCFU},${{CODE}_DIAL_OPTIONS})
exten => docfu,n,Return()
exten => docfb,1(docfb),Set(RTCFB=${IF($["${VMBOX}"!="novm"]?${{CODE}_RINGTIMER}:"")})
exten => docfb,n,Dial(Local/${CFBEXT}@{CODE}-from-internal/n,${RTCFB},${{CODE}_DIAL_OPTIONS})
exten => docfb,n,Return()
exten => s-BUSY,1,Noop(Extension is reporting BUSY and not passing to Voicemail)
exten => s-BUSY,n,GotoIf($["${IVR_RETVM}"="RETURN" & "${IVR_CONTEXT}"!=""]?exit,1)
exten => s-BUSY,n,Playtones(busy)
exten => s-BUSY,n,Busy(20)
exten => _s-!,1,Noop(IVR_RETVM: ${IVR_RETVM} IVR_CONTEXT: ${IVR_CONTEXT})
exten => _s-!,n,GotoIf($["${IVR_RETVM}"="RETURN" & "${IVR_CONTEXT}"!=""]?exit,1)
exten => _s-!,n,Playtones(congestion)
exten => _s-!,n,Congestion(10)
exten => exit,1,Playback(beep&line-busy-transfer-menu&silence/1)
exten => exit,n,MacroExit()

; end of [macro-exten-vm]


[macro-{CODE}-simple-dial]
include => macro-{CODE}-simple-dial-custom
exten => s,1,Set(__EXTTOCALL=${ARG1})
exten => s,n,Set(RT=${ARG2})
exten => s,n,Set(CFUEXT=${DB(CFU/{CODE}/${EXTTOCALL})})
exten => s,n,Set(CFBEXT=${DB(CFB/{CODE}/${EXTTOCALL})})
exten => s,n,Set(CWI_TMP=${CWIGNORE})
exten => s,n(macrodial),Macro({CODE}-dial-one,${RT},${{CODE}_DIAL_OPTIONS},${EXTTOCALL})
exten => s,n,Set(__CWIGNORE=${CWI_TMP})
exten => s,n,Set(PR_DIALSTATUS=${DIALSTATUS})
exten => s,n(calldocfu),GosubIf($["${PR_DIALSTATUS}"="NOANSWER" & "${CFUEXT}"!=""]?docfu,1)
exten => s,n(calldocfb),GosubIf($["${PR_DIALSTATUS}"="BUSY" & "${CFBEXT}"!=""]?docfb,1)
exten => s,n,Set(DIALSTATUS=${PR_DIALSTATUS})
exten => s,n,Goto(s-${DIALSTATUS},1)
exten => docfu,1,GotoIf($["${DB(EXTUSER/{CODE}/${CFUEXT}/device)}" = "" ]?chlocal)
exten => docfu,n,Dial(Local/${CFUEXT}@{CODE}-ext-local,${RT},${{CODE}_DIAL_OPTIONS})
exten => docfu,n,Return()
exten => docfu,n(chlocal),Dial(Local/${CFUEXT}@{CODE}-from-internal/n,${RT},${{CODE}_DIAL_OPTIONS})
exten => docfu,n,Return()
exten => docfb,1,GotoIf($["${DB(EXTUSER/{CODE}/${CFBEXT}/device)}" = "" ]?chlocal)
exten => docfb,n,Dial(Local/${CFBEXT}@{CODE}-ext-local,${RT},${{CODE}_DIAL_OPTIONS})
exten => docfb,n,Return()
exten => docfb,n(chlocal),Dial(Local/${CFBEXT}@{CODE}-from-internal/n,${RT},${{CODE}_DIAL_OPTIONS})
exten => docfb,n,Return()
exten => _s-.,1,Noop(Extension is reporting ${EXTEN})

; end of [macro-{CODE}-simple-dial]


[macro-{CODE}-dial-one]
include => macro-{CODE}-dial-one-custom
exten => s,1,Set(DEXTEN=${ARG3})
exten => s,n,Set(DIALSTATUS_CW=)
exten => s,n,GosubIf($["${FROM_DID}"!="" & "${SCREEN}"="" & "${DB(EXTUSER/{CODE}/${DEXTEN}/screen)}"!=""]?screen,1)
exten => s,n,GosubIf($["${DB(CF/{CODE}/${DEXTEN})}"!=""]?cf,1)
exten => s,n,GotoIf($["${DEXTEN:-1}"="#" | "${DB(DND/{CODE}/${DEXTEN})}"=""]?skip1)
exten => s,n,Set(DEXTEN=)
exten => s,n,Set(DIALSTATUS=BUSY)
exten => s,n(skip1),GotoIf($["${DEXTEN}"=""]?nodial)
exten => s,n,GotoIf($["${DEXTEN:-1}"="#"]?continue)
exten => s,n,Set(EXTHASCW=${IF($["${CWIGNORE}"!=""]?"":${DB(CW/{CODE}/${DEXTEN})})})
exten => s,n,GotoIf($["${EXTHASCW}"="" | "${DB(CFB/{CODE}/${DEXTEN})}"!="" | "${DB(CFU/{CODE}/${DEXTEN})}"!=""]?next1:cwinusebusy)
exten => s,n(next1),GotoIf($["${DB(CFU/{CODE}/${DEXTEN})}"!="" & ("${EXTENSION_STATE(${DEXTEN}@{CODE}-ext-local)}"="UNAVAILABLE" | "${EXTENSION_STATE(${DEXTEN}@{CODE}-ext-local)}"="UNKNOWN")]?docfu:skip3)
exten => s,n(docfu),Set(DEXTEN=)
exten => s,n,Set(DIALSTATUS=NOANSWER)
exten => s,n,Goto(nodial)
exten => s,n(skip3),GotoIf($["${EXTHASCW}"="" | "${DB(CFB/{CODE}/${DEXTEN})}"!=""]?next2:continue)
exten => s,n(next2),GotoIf($["${EXTENSION_STATE(${DEXTEN}@{CODE}-ext-local)}"="NOT_INUSE" | "${EXTENSION_STATE(${DEXTEN}@{CODE}-ext-local)}"="UNAVAILABLE" | "${EXTENSION_STATE(${DEXTEN}@{CODE}-ext-local)}"="UNKNOWN"]?continue)
exten => s,n,ExecIf($["${DB(CFB/{CODE}/${DEXTEN})}"!="" & "${CFIGNORE}"=""]?Set(DIALSTATUS=BUSY))
exten => s,n,GotoIf($["${EXTHASCW}"!="" | "${DEXTEN:-1}"="#"]?cwinusebusy)
exten => s,n,Set(DEXTEN=)
exten => s,n,Set(DIALSTATUS=BUSY)
exten => s,n,Goto(nodial)
exten => s,n(cwinusebusy),GotoIf($["${EXTHASCW}"!="" & "${CWINUSEBUSY}"!=""]?next3:continue)
exten => s,n(next3),ExecIf($["${EXTENSION_STATE(${DEXTEN}@{CODE}-ext-local)}"!="UNAVAILABLE" & "${EXTENSION_STATE(${DEXTEN}@{CODE}-ext-local)}"!="NOT_INUSE" & "${EXTENSION_STATE(${DEXTEN}@{CODE}-ext-local)}"!="UNKNOWN"]?Set(DIALSTATUS_CW=BUSY))
exten => s,n(continue),GotoIf($["${DEXTEN}"=""]?nodial)
exten => s,n,GosubIf($["${DEXTEN:-1}"!="#"]?dstring,1:dlocal,1)
exten => s,n,GotoIf($[${LEN(${DSTRING})}=0]?nodial)
exten => s,n,GotoIf($["${DEXTEN:-1}"!="#"]?skiptrace)
exten => s,n,GosubIf($[${REGEX("^[\+]?[0-9]+$" ${CALLERID(number)})} = 1]?ctset,1:ctclear,1)
exten => s,n(skiptrace),Set(D_OPTIONS=${IF($["${NODEST}"!="" & ${REGEX("(M[(]{CODE}-auto-blkvm[)])" ${ARG2})} != 1]?${ARG2}M({CODE}-auto-blkvm):${ARG2})})
exten => s,n,ExecIf($["${ALERT_INFO}"!=""]?SIPAddHeader(Alert-Info: ${ALERT_INFO}))
exten => s,n,ExecIf($["${SIPADDHEADER}"!=""]?SIPAddHeader(${SIPADDHEADER}))
exten => s,n,ExecIf($["${MOHCLASS}"!=""]?Set(CHANNEL(musicclass)=${MEETME_MUSIC}))
exten => s,n,GosubIf($["${QUEUEWAIT}"!=""]?qwait,1)
exten => s,n,Set(__CWIGNORE=${CWIGNORE})
exten => s,n,Set(__KEEPCID=TRUE)
exten => s,n,Dial(${DSTRING},${ARG1},${D_OPTIONS})
exten => s,n,ExecIf($["${DIALSTATUS_CW}"!=""]?Set(DIALSTATUS=${DIALSTATUS_CW}))
exten => s,n,GosubIf($["${SCREEN}"!=""|"${DIALSTATUS}"="ANSWER"]?s-${DIALSTATUS},1)
exten => s,n,MacroExit()
exten => s,n(nodial),ExecIf($["${DIALSTATUS}" = ""]?Set(DIALSTATUS=NOANSWER))
exten => s,n,Noop(Returned from dial-one with nothing to call and DIALSTATUS: ${DIALSTATUS})
exten => s,n,MacroExit()
exten => h,1,Macro({CODE}-hangupcall,)
exten => screen,1,GotoIf($["${DB(EXTUSER/{CODE}/${DEXTEN}/screen)}"!="nomemory" | "${CALLERID(number)}"=""]?memory)
exten => screen,n,ExecIf($[${REGEX("^[0-9a-zA-Z ]+$" ${CALLERID(number)})} = 1]?System(rm -f ${ASTVARLIBDIR}/sounds/priv-callerintros/{dominio}/${CALLERID(number)}.*))
exten => screen,n(memory),Set(__SCREEN=${DB(EXTUSER/{CODE}/${DEXTEN}/screen)})
exten => screen,n,Set(__SCREEN_EXTEN=${DEXTEN})
exten => screen,n,Set(ARG2=${ARG2}p)
exten => screen,n,Return()
exten => cf,1,Set(CFEXTUSER=${IF($["${EXTUSER}"=""]?${CALLERID(number)}:${EXTUSER})})
exten => cf,n,ExecIf($["${DB(CF/{CODE}/${DEXTEN})}"="${CFEXTUSER}" | "${DB(CF/{CODE}/${DEXTEN})}"="${REALCALLERIDNUM}" | "${CUT(CUT(BLINDTRANSFER,-,1),/,1)}" = "${DB(CF/{CODE}/${DEXTEN})}" | "${DEXTEN}"="${DB(CF/{CODE}/${DEXTEN})}"]?Return())
exten => cf,n,Set(DEXTEN=${IF($["${CFIGNORE}"=""]?"${DB(CF/{CODE}/${DEXTEN})}#":"")})
exten => cf,n,ExecIf($["${DEXTEN}"!=""]?Return())
exten => cf,n,Set(DIALSTATUS=NOANSWER)
exten => cf,n,Return()
exten => qwait,1,ExecIf($["${SAVEDCIDNAME}" = ""]?Set(__SAVEDCIDNAME=${CALLERID(name)}))
exten => qwait,n,Set(ELAPSED=${MATH($[${EPOCH}+30-${QUEUEWAIT}]/60,int)})
exten => qwait,n,Set(CALLERID(name)=M${ELAPSED}:${SAVEDCIDNAME})
exten => qwait,n,Return()
exten => ctset,1,Set(DB(CALLTRACE/{CODE}/${DEXTEN})=${CALLERID(number)})
exten => ctset,n,Return()
exten => ctclear,1,Noop(Deleting: CALLTRACE/{CODE}/${DEXTEN} ${DB_DELETE(CALLTRACE/{CODE}/${DEXTEN})})
exten => ctclear,n,Return()
exten => dstring,1,Set(DSTRING=)
exten => dstring,n,Set(DEVICES=${DB(EXTUSER/{CODE}/${DEXTEN}/device)})
exten => dstring,n,ExecIf($["${DEVICES}"=""]?Return())
exten => dstring,n,ExecIf($["${DEVICES:0:1}"="&"]?Set(DEVICES=${DEVICES:1}))
exten => dstring,n,Set(LOOPCNT=${FIELDQTY(DEVICES,&)})
exten => dstring,n,Set(ITER=1)
exten => dstring,n(begin),Set(THISDIAL=${DB(DEVICE/{CODE}/${CUT(DEVICES,&,${ITER})}/dial)})
exten => dstring,n,GosubIf($["${ASTCHANDAHDI}" != ""]?zap2dahdi,1)
exten => dstring,n,Set(DSTRING=${DSTRING}${THISDIAL}&)
exten => dstring,n,Set(ITER=$[${ITER}+1])
exten => dstring,n,GotoIf($[${ITER}<=${LOOPCNT}]?begin)
exten => dstring,n,Set(DSTRING=${DSTRING:0:$[${LEN(${DSTRING})}-1]})
exten => dstring,n,Return()
exten => dlocal,1,Set(DSTRING=Local/${DEXTEN:0:${MATH(${LEN(${DEXTEN})}-1,int)}}@{CODE}-from-internal/n)
exten => dlocal,n,Return()
exten => zap2dahdi,1,ExecIf($["${THISDIAL}" = ""]?Return())
exten => zap2dahdi,n,Set(NEWDIAL=)
exten => zap2dahdi,n,Set(LOOPCNT2=${FIELDQTY(THISDIAL,&)})
exten => zap2dahdi,n,Set(ITER2=1)
exten => zap2dahdi,n(begin2),Set(THISPART2=${CUT(THISDIAL,&,${ITER2})})
exten => zap2dahdi,n,ExecIf($["${THISPART2:0:3}" = "ZAP"]?Set(THISPART2=DAHDI${THISPART2:3}))
exten => zap2dahdi,n,Set(NEWDIAL=${NEWDIAL}${THISPART2}&)
exten => zap2dahdi,n,Set(ITER2=$[${ITER2} + 1])
exten => zap2dahdi,n,GotoIf($[${ITER2} <= ${LOOPCNT2}]?begin2)
exten => zap2dahdi,n,Set(THISDIAL=${NEWDIAL:0:$[${LEN(${NEWDIAL})}-1]})
exten => zap2dahdi,n,Return()
exten => s-NOANSWER,1,Macro({CODE}-vm,${SCREEN_EXTEN},BUSY,${IVR_RETVM})
exten => s-NOANSWER,n,ExecIf($["${IVR_RETVM}"!="RETURN" | "${IVR_CONTEXT}"=""]?Hangup())
exten => s-NOANSWER,n,Return()
exten => s-TORTURE,1,Goto({CODE}-app-blackhole,musiconhold,1)
exten => s-TORTURE,n,Macro({CODE}-hangupcall,)
exten => s-DONTCALL,1,Answer
exten => s-DONTCALL,n,Wait(1)
exten => s-DONTCALL,n,Zapateller()
exten => s-DONTCALL,n,Playback(ss-noservice)
exten => s-DONTCALL,n,Macro({CODE}-hangupcall,)
; end of [macro-{CODE}-dial-one]


[macro-{CODE}-hangupcall]
include => macro-hangupcall-custom
; setear el nombre del dominio al que pertenece la llamada en caso de que este no haya sido ya seteado
exten => s,1,ExecIf($["${CDR(organization_domain)}"=""]?Set(CDR(organization_domain)={DOMAIN}))
; Validar si el archivo de MixMon existe. Puede no existir si la llamada cuelga
; del lado origen antes que el destino conteste (Elastix bug #422)
exten => s,n,GotoIf($["${CDR(userfield)}" = ""]?endmixmoncheck)
; Este codigo es fragil. Actualizar si se averigua la manera de consultar AST_MONITOR_DIR
exten => s,n,System(test -e ${{CODE}_MIXMON_DIR}${{CODE}_CALLFILENAME}.${{CODE}_MIXMON_FORMAT})
exten => s,n,Noop(SYSTEMSTATUS = ${SYSTEMSTATUS})
exten => s,n,GotoIf($["${SYSTEMSTATUS}" = "SUCCESS"]?endmixmoncheck)
; Si archivo MixMon no existe, se anula CDR(userfield)
exten => s,n,Set(CDR(userfield)=)
exten => s,n(endmixmoncheck),Noop(End of MIXMON check)

; Validar si existe el archivo de grabacion de MeetMe. Puede que el archivo de
; grabacion sea distinto del especificado en el contexto, porque solo obedece
; la asignacion del primer conferencista que entra a la conferencia.
exten => s,n,GotoIf($["${MEETME_RECORDINGFILE}" = ""]?nomeetmemon)
exten => s,n,ExecIf($["${MEETME_RECORDINGFORMAT}"=""]?Set(MEETME_RECORDINGFORMAT=wav))
exten => s,n,Set(MEETME_FILE_EXIST=${STAT(e,${MEETME_RECORDINGFILE}.${MEETME_RECORDINGFORMAT})})
exten => s,n,Noop(MEETME_FILE_EXIST = ${MEETME_FILE_EXIST})
exten => s,n,GotoIf($["${MEETME_FILE_EXIST}" != "1"]?nomeetmemon)
; existe el archivo de grabacion de la conferencia
exten => s,n,Set(CDR(userfield)=audio:${MEETME_RECORDINGFILE}.${MEETME_RECORDINGFORMAT})
exten => s,n(nomeetmemon),Noop(MEETME_RECORDINGFILE=${MEETME_RECORDINGFILE})

; Validar si existe el archivo de grabacion bajo demanda para la extension
exten => s,n,GotoIf($["${TOUCH_MONITOR_OUTPUT}" = ""]?noautomon)
exten => s,n,StopMonitor()
exten => s,n,System(test -e /var/spool/asterisk/monitor/${TOUCH_MONITOR_OUTPUT}-in.wav)
exten => s,n,Noop(SYSTEMSTATUS = ${SYSTEMSTATUS})
exten => s,n,GotoIf($["${SYSTEMSTATUS}" != "SUCCESS"]?noautomon)
exten => s,n,System(soxmix /var/spool/asterisk/monitor/${TOUCH_MONITOR_OUTPUT}-in.wav /var/spool/asterisk/monitor/${TOUCH_MONITOR_OUTPUT}-out.wav /var/spool/asterisk/monitor/{DOMAIN}/${TOUCH_MONITOR_OUTPUT}.wav)
exten => s,n,GotoIf($["${SYSTEMSTATUS}" != "SUCCESS"]?noautomon)
exten => s,n,Set(CDR(userfield)=audio:${TOUCH_MONITOR_OUTPUT}.wav)
exten => s,n(noautomon),Noop(TOUCH_MONITOR_OUTPUT=${TOUCH_MONITOR_OUTPUT})

; Validar si existe el archivo de grabacion de la cola
exten => s,n,GotoIf($["${MONITOR_FILENAME}" = ""]?noautomon2)
exten => s,n,ExecIf($["${MONITOR_FILENAME_FORMAT}"=""]?Set(MONITOR_FILENAME_FORMAT=wav))
exten => s,n,System(test -e ${MONITOR_FILENAME}.${MONITOR_FILENAME_FORMAT})
exten => s,n,Noop(SYSTEMSTATUS = ${SYSTEMSTATUS})
exten => s,n,GotoIf($["${SYSTEMSTATUS}" = "APPERROR"]?errornoautomon)
exten => s,n,Set(CDR(userfield)=audio:${MONITOR_FILENAME}.${MONITOR_FILENAME_FORMAT})
exten => s,n(errornoautomon),Noop(End of MONITOR QUEUE check)
exten => s,n(noautomon2),Noop(MONITOR_FILENAME=${MONITOR_FILENAME})

exten => s,n(start),GotoIf($["${USE_CONFIRMATION}"="" | "${RINGGROUP_INDEX}"="" | "${CHANNEL}"!="${UNIQCHAN}"]?skiprg)
exten => s,n,Noop(Cleaning Up Confirmation Flag: RG/{CODE}/${RINGGROUP_INDEX}/${CHANNEL})
exten => s,n(delrgi),Noop(Deleting: RG/{CODE}/${RINGGROUP_INDEX}/${CHANNEL} ${DB_DELETE(RG/{CODE}/${RINGGROUP_INDEX}/${CHANNEL})})
exten => s,n(skiprg),GotoIf($["${BLKVM_BASE}"="" | "BLKVM/{CODE}/${BLKVM_BASE}/${CHANNEL}"!="${BLKVM_OVERRIDE}"]?skipblkvm)
exten => s,n,Noop(Cleaning Up Block VM Flag: ${BLKVM_OVERRIDE})
exten => s,n(delblkvm),Noop(Deleting: ${BLKVM_OVERRIDE} ${DB_DELETE(${BLKVM_OVERRIDE})})
exten => s,n(skipblkvm),GotoIf($["${FMGRP}"="" | "${FMUNIQUE}"="" | "${CHANNEL}"!="${FMUNIQUE}"]?theend)
exten => s,n(delfmrgp),Noop(Deleting: FM/DND/{CODE}/${FMGRP}/${CHANNEL} ${DB_DELETE(FM/DND/{CODE}/${FMGRP}/${CHANNEL})})
exten => s,n(theend),Hangup
